# Sprint 1 Manual Test Plan

## 概要

このドキュメントは、Sprint 1（M1 + M2）の受け入れ条件を、専用iOSアプリなしで汎用BLEアプリを使用して検証するための手順書です。
第三者がこの手順書のみで同じ結果を再現できることを目標としています。

**対象マイルストーン**:
- M1: FW Bring-up（I2C + PCA9685 + 手動BLE Write）
- M2: 安全停止（ARM/DISARM + デッドマン）と最小テレメトリ

**依存イシュー**: S1-06, S1-07, S1-08

**最終更新**: 2026-01-03

---

## 1. 事前準備

### 1.1 必要な機材・ソフトウェア

**ハードウェア**:
- XIAO nRF52840（ファームウェア書き込み済み）
- PCA9685 PWMコントローラ（I2C接続済み）
- サーボモーター（CH0に接続）
- バッテリー（PCA9685への電源供給）
- USBケーブル（シリアルログ確認用、オプション）

**ソフトウェア**:
- **iOS**: nRF Connect for Mobile または LightBlue
- **Android**: nRF Connect for Mobile
- **macOS**: LightBlue または nRF Connect
- **シリアルターミナル**（オプション）: minicom, screen, または Arduino IDE Serial Monitor（115200 bps）

### 1.2 配線確認

テスト開始前に以下を確認してください：

1. **I2C接続**:
   - XIAO SDA → PCA9685 SDA
   - XIAO SCL → PCA9685 SCL
   - XIAO GND → PCA9685 GND
   - 詳細: `docs/wiring_pca9685.md`

2. **サーボ接続**:
   - サーボモーター → PCA9685 CH0（ピン0-1-2）

3. **電源**:
   - PCA9685に適切な電源が供給されている（5-6V推奨）
   - XIAOはUSB電源またはバッテリー電源

4. **動作確認**:
   - XIAO nRF52840のLEDが点灯している
   - ファームウェアが正常に起動している

### 1.3 参照ドキュメント

テスト中に以下のドキュメントを参照できるようにしてください：

- **BLEプロトコル詳細**: `docs/ble_protocol.md`
- **プロトコル仕様**: `shared/protocol/spec/legctrl_protocol.md`
- **安全システムテスト**: `docs/safety_test.md`
- **受入検証**: `docs/S1-08_acceptance_validation.md`

---

## 2. テストシナリオ

### TS-01: 接続確認（広告 → 接続）

#### 目的
BLE広告が正しく送信され、デバイスに接続できることを確認します。

#### 前提条件
- XIAO nRF52840が起動している
- BLEテストアプリがインストールされている

#### 手順

1. **BLEテストアプリを起動**
   - nRF ConnectまたはLightBlueを開く

2. **デバイスをスキャン**
   - "Scan"ボタンをタップ
   - デバイスリストが表示されるまで待つ

3. **デバイスを確認**
   - デバイス名 "LegCtrl" を探す
   - RSSIが表示されていることを確認（例: -50 dBm）

4. **接続**
   - "LegCtrl" をタップして接続
   - 接続状態が "Connected" になることを確認

5. **Serviceを確認**
   - Service一覧が表示される
   - Service UUID `12345678-1234-1234-1234-123456789abc` を探す
   - Serviceを展開する

6. **Characteristicを確認**
   - Command Characteristic: `12345678-1234-1234-1234-123456789abd`
     - Properties: Write, Write Without Response
   - Telemetry Characteristic: `12345678-1234-1234-1234-123456789abe`
     - Properties: Notify

#### 観測点

| 項目 | 観測方法 | 期待結果 |
|------|---------|---------|
| BLE広告 | スキャン結果 | デバイス名 "LegCtrl" が表示される |
| Service UUID | Service一覧 | `12345678-1234-1234-1234-123456789abc` が存在する |
| Command Char | Characteristic一覧 | UUID `...789abd`, Properties: Write, Write Without Response |
| Telemetry Char | Characteristic一覧 | UUID `...789abe`, Properties: Notify |
| 接続状態 | アプリ画面 | "Connected" と表示される |

#### 成功/失敗の判断基準

**成功**: すべての観測点で期待結果が確認できた  
**失敗**: いずれかの観測点で期待結果が得られなかった

#### トラブルシューティング

- **デバイスが見つからない**: ファームウェアが正常に起動しているか確認、XIAOをリセット
- **接続できない**: 他のデバイスが接続していないか確認、XIAOをリセット
- **Serviceが見つからない**: 接続後、数秒待ってから再度確認

---

### TS-02: DISARM確認 → ARM

#### 目的
システムが初期状態でDISARMED状態であり、ARMコマンドでARMED状態に遷移することを確認します。

#### 前提条件
- TS-01が完了している（BLE接続済み）

#### 手順

1. **Telemetry Notifyを有効化**
   - Telemetry Characteristic (`...789abe`) をタップ
   - "Notify" ボタンまたはアイコンをタップして有効化
   - Notifyが開始されることを確認（データが定期的に受信される）

2. **初期状態（DISARMED）を確認**
   - 受信したTelemetryデータを確認（Hex形式）
   - 最初のパケットを記録

3. **ARMコマンドを送信**
   - Command Characteristic (`...789abd`) をタップ
   - Write type: "Write Without Response" を選択
   - 値を入力（Hex）: `01 01 00 00`
   - "Write" ボタンを押す

4. **ARM状態を確認**
   - Telemetryデータを確認（100ms以内に更新される）
   - 新しいパケットを記録

5. **DISARMコマンドを送信**
   - 値を入力（Hex）: `01 02 00 00`
   - "Write" ボタンを押す

6. **DISARM状態を確認**
   - Telemetryデータを確認
   - 状態が元に戻ることを確認

#### 観測点

| 項目 | 観測方法 | 期待結果 |
|------|---------|---------|
| 初期状態 | Telemetry Byte 4 | `0x00` (DISARMED) |
| 初期エラーコード | Telemetry Byte 5 | `0x00` (ERR_NONE) |
| ARM後の状態 | Telemetry Byte 4 | `0x01` (ARMED) |
| ARM後のエラーコード | Telemetry Byte 5 | `0x00` (ERR_NONE) |
| DISARM後の状態 | Telemetry Byte 4 | `0x00` (DISARMED) |
| Notify周期 | 受信間隔 | 約100ms（10 Hz） |

#### Telemetryデータ例

**初期状態（DISARMED）**:
```
01 10 08 00 00 00 00 00 E8 1C 00 00
            ↑  ↑  ↑  ↑
            │  │  └──┴─ battery_mv = 0x1CE8 (7400 mV)
            │  └─ last_cmd_age_ms (Little Endian)
            └─ error_code = 0x00 (ERR_NONE)
         state = 0x00 (DISARMED)
```

**ARM後（ARMED）**:
```
01 10 08 00 01 00 XX XX E8 1C 00 00
            ↑
         state = 0x01 (ARMED)
```

#### 成功/失敗の判断基準

**成功**:
- 初期状態がDISARMED（`0x00`）である
- ARMコマンド送信後、100ms以内にARMED（`0x01`）に遷移する
- DISARMコマンド送信後、100ms以内にDISARMED（`0x00`）に戻る
- エラーコードが常に`0x00`（正常）である

**失敗**:
- 初期状態がDISARMEDでない
- ARMコマンドが無視される、または状態が変化しない
- DISARMコマンドが無視される

---

### TS-03: サーボCH0に値Write → 動作確認

#### 目的
ARMED状態でサーボコマンドを送信し、サーボが指定された位置に移動することを確認します。

#### 前提条件
- TS-02が完了している（ARM/DISARM動作確認済み）
- サーボがCH0に接続されている

#### 手順

1. **ARMコマンドを送信**
   - Command Characteristic に `01 01 00 00` を送信
   - Telemetryで `state = 0x01` を確認

2. **中立位置（1500 us）にセット**
   - Command Characteristic に以下を送信:
     ```
     01 03 02 00 DC 05
     ```
     - `01`: version
     - `03`: msg_type (CMD_SET_SERVO_CH0)
     - `02`: payload_len
     - `00`: reserved
     - `DC 05`: pulse_us = 1500 (Little Endian)
   - サーボの動きを目視確認
   - Telemetryの `last_cmd_age_ms` が小さい値（< 100ms）であることを確認

3. **最小位置（500 us）にセット**
   - Command Characteristic に `01 03 02 00 F4 01` を送信
   - サーボが片方の端に移動することを目視確認
   - 動作が滑らかであることを確認

4. **最大位置（2500 us）にセット**
   - Command Characteristic に `01 03 02 00 C4 09` を送信
   - サーボが反対側の端に移動することを目視確認

5. **中間位置（2000 us）にセット**
   - Command Characteristic に `01 03 02 00 D0 07` を送信
   - サーボが中間位置に移動することを目視確認

6. **DISARMED状態でのコマンド無視を確認**
   - DISARMコマンドを送信: `01 02 00 00`
   - Telemetryで `state = 0x00` を確認
   - サーボコマンドを送信: `01 03 02 00 DC 05`
   - サーボが**動かないこと**を確認

#### 観測点

| 項目 | 観測方法 | 期待結果 |
|------|---------|---------|
| 1500 us時の位置 | 目視 | サーボが中立位置（約90度）にある |
| 500 us時の位置 | 目視 | サーボが最小位置（約0度）にある |
| 2500 us時の位置 | 目視 | サーボが最大位置（約180度）にある |
| 2000 us時の位置 | 目視 | サーボが中間位置（約135度）にある |
| last_cmd_age_ms | Telemetry Bytes 6-7 | < 100ms（コマンド受信が確認されている） |
| DISARM時の動作 | 目視 | サーボが動かない |

#### パルス幅 ↔ Hex変換表

| パルス幅 (us) | Decimal | Hex (Little Endian) | コマンド全体 |
|--------------|---------|---------------------|-------------|
| 500 | 500 | `F4 01` | `01 03 02 00 F4 01` |
| 1000 | 1000 | `E8 03` | `01 03 02 00 E8 03` |
| 1500 | 1500 | `DC 05` | `01 03 02 00 DC 05` |
| 2000 | 2000 | `D0 07` | `01 03 02 00 D0 07` |
| 2500 | 2500 | `C4 09` | `01 03 02 00 C4 09` |

#### 成功/失敗の判断基準

**成功**:
- ARMED状態で各パルス幅に対してサーボが適切な位置に移動する
- サーボの動きが滑らかで、ジッタがない
- `last_cmd_age_ms` がコマンド送信後に小さい値（< 100ms）に更新される
- DISARMED状態ではサーボコマンドが無視される

**失敗**:
- サーボが動かない、または意図しない位置に移動する
- サーボの動きがカクカクする、またはジッタが激しい
- DISARMED状態でサーボが動いてしまう

#### トラブルシューティング

- **サーボが動かない**:
  - ARMED状態になっているか確認（Telemetry確認）
  - サーボの電源が供給されているか確認
  - I2C配線を確認
  - シリアルログでエラーメッセージを確認

- **サーボが意図しない動きをする**:
  - パルス幅のエンディアンを確認（Little Endianで送信しているか）
  - サーボの種類を確認（一部のサーボは異なる範囲を使用）

---

### TS-04: 送信停止 → デッドマン停止確認

#### 目的
コマンド送信を停止した際に、200ms以内にデッドマンタイムアウトが発生し、サーボが停止することを確認します。

#### 前提条件
- TS-03が完了している（サーボ制御動作確認済み）

#### 手順

1. **ARMコマンドを送信**
   - Command Characteristic に `01 01 00 00` を送信
   - Telemetryで `state = 0x01` を確認

2. **サーボコマンドを送信**
   - Command Characteristic に `01 03 02 00 DC 05` を送信（1500 us）
   - サーボが動作していることを確認

3. **Telemetryを連続監視**
   - Telemetry Notifyを観察
   - タイマーを準備（スマートフォンのタイマーアプリ等）

4. **コマンド送信を停止**
   - **200ms以上、何もコマンドを送信しない**
   - Telemetryデータを記録し続ける（少なくとも3-4パケット）
   - サーボの動作を目視確認

5. **FAULT状態を確認**
   - Telemetryで状態が変化することを確認
   - サーボが停止することを確認

6. **復帰手順を確認**
   - DISARMコマンドを送信: `01 02 00 00`
   - Telemetryで `state = 0x00`, `error_code = 0x00` を確認
   - ARMコマンドを送信: `01 01 00 00`
   - サーボコマンドを送信して動作を確認

#### 観測点

| 項目 | 観測方法 | 期待結果 |
|------|---------|---------|
| last_cmd_age_ms増加 | Telemetry Bytes 6-7 | 0ms → 100ms → 200ms と増加 |
| FAULT遷移タイミング | Telemetry Byte 4 | 200ms経過後に `0x02` (FAULT) |
| エラーコード | Telemetry Byte 5 | `0x01` (ERR_DEADMAN_TIMEOUT) |
| サーボ停止 | 目視 | サーボの動きが止まる |
| 復帰後の状態 | Telemetry | DISARM → ARM で正常動作 |

#### Telemetryデータ例

**コマンド送信直後（last_cmd_age_ms = 50ms）**:
```
01 10 08 00 01 00 32 00 E8 1C 00 00
                  ↑  ↑
                  └──┴─ 0x0032 = 50 ms
```

**100ms経過後**:
```
01 10 08 00 01 00 64 00 E8 1C 00 00
                  ↑  ↑
                  └──┴─ 0x0064 = 100 ms
```

**200ms経過後（FAULT遷移）**:
```
01 10 08 00 02 01 C8 00 E8 1C 00 00
            ↑  ↑  ↑  ↑
            │  │  └──┴─ 0x00C8 = 200 ms
            │  └─ 0x01 (ERR_DEADMAN_TIMEOUT)
            └─ 0x02 (FAULT)
```

#### 成功/失敗の判断基準

**成功**:
- `last_cmd_age_ms` が約100ms間隔で増加する（0ms → 100ms → 200ms）
- 200ms経過後、確実にFAULT状態（`state = 0x02`）に遷移する
- エラーコードが `0x01` (ERR_DEADMAN_TIMEOUT) になる
- サーボ出力が停止する（目視確認可能）
- DISARM → ARM で正常に復帰できる

**失敗**:
- 200ms経過してもFAULT状態に遷移しない
- 300ms以上経過してからFAULT状態に遷移する（遅すぎる）
- サーボが停止しない
- 復帰できない

#### 注意事項

- デッドマンタイムアウトは**安全機能**です。必ず200ms以内に発動する必要があります
- `last_cmd_age_ms` は100ms周期のTelemetryで更新されるため、実際のタイムアウトは200-300msの間で発生する可能性があります
- 重要なのは「200ms無通信で確実に停止する」ことです

---

### TS-05: 切断 → デッドマン停止確認

#### 目的
BLE切断時に即座にサーボが停止し、FAULT状態に遷移することを確認します。

#### 前提条件
- TS-03が完了している（サーボ制御動作確認済み）

#### 手順

1. **ARMコマンドを送信**
   - Command Characteristic に `01 01 00 00` を送信
   - Telemetryで `state = 0x01` を確認

2. **サーボコマンドを送信**
   - Command Characteristic に `01 03 02 00 DC 05` を送信（1500 us）
   - サーボが動作していることを確認

3. **BLE切断を実行**
   - BLEテストアプリで "Disconnect" ボタンをタップ
   - サーボの動作を**即座に**目視確認

4. **再接続**
   - 数秒待つ
   - 再度 "LegCtrl" デバイスに接続
   - Telemetry Notifyを有効化

5. **初期状態を確認**
   - Telemetryデータを確認
   - 状態とエラーコードを記録

6. **復帰手順を確認**
   - ARMコマンドを送信（もしFAULT状態なら、先にDISARMを送信）
   - サーボコマンドを送信して動作を確認

#### 観測点

| 項目 | 観測方法 | 期待結果 |
|------|---------|---------|
| 切断時のサーボ停止 | 目視 | 即座に停止（目視で遅延なし） |
| 再接続後の状態 | Telemetry Byte 4 | `0x00` (DISARMED) または `0x02` (FAULT) |
| 再接続後のエラーコード | Telemetry Byte 5 | `0x00` (ERR_NONE) または適切なエラーコード |
| last_cmd_age_ms | Telemetry Bytes 6-7 | リセットされている（0または小さい値） |
| 復帰動作 | 目視 | ARM後に正常動作 |

#### 成功/失敗の判断基準

**成功**:
- BLE切断後、**即座に**（1秒以内に）サーボが停止する
- 再接続後、安全な初期状態（DISARMEDまたはFAULT）に戻る
- `last_cmd_age_ms` がリセットされている
- ARM後に正常にサーボ制御できる

**失敗**:
- 切断後、サーボが動き続ける（数秒以上）
- 再接続後、ARMED状態のままになる（危険）
- 復帰できない

#### 注意事項

- BLE切断時の停止は**即座**である必要があります（デッドマンタイムアウトの200msを待つ必要はありません）
- これはフェイルセーフ機能の一部であり、最も重要な安全機能です

---

### TS-06: Telemetry Notifyの確認（state, last_cmd_age_ms, battery_mv 等）

#### 目的
Telemetry Notifyが正しい周期（10 Hz）で送信され、すべてのフィールドが正しく受信できることを確認します。

#### 前提条件
- TS-01が完了している（BLE接続済み）

#### 手順

1. **Telemetry Notifyを有効化**
   - Telemetry Characteristic (`...789abe`) のNotifyを有効化

2. **Telemetryパケットを記録**
   - **5秒間**、受信したすべてのTelemetryパケットを記録
   - パケット数をカウント
   - 受信間隔を測定（可能な場合）

3. **パケット構造を解析**
   - 任意の1つのパケットを選択
   - 各バイトを解析して値を確認

4. **各フィールドの動作確認**
   - **state**: ARM/DISARMコマンドを送信して変化を確認
   - **error_code**: デッドマンタイムアウトを発生させて変化を確認
   - **last_cmd_age_ms**: コマンド送信/停止で変化を確認
   - **battery_mv**: 値を確認（v0.1ではスタブ実装のため固定値7400 mV）

#### 観測点

| 項目 | 観測方法 | 期待結果 |
|------|---------|---------|
| パケット数（5秒間） | カウント | 約50パケット（±5パケット） |
| 受信周期 | 時間測定 | 約100ms（±10ms） |
| パケット長 | バイト数 | 12 bytes |
| ヘッダ - version | Byte 0 | `0x01` |
| ヘッダ - msg_type | Byte 1 | `0x10` (TELEMETRY) |
| ヘッダ - payload_len | Byte 2 | `0x08` |
| ヘッダ - reserved | Byte 3 | `0x00` |
| state | Byte 4 | `0x00`/`0x01`/`0x02` |
| error_code | Byte 5 | `0x00` または適切なエラーコード |
| last_cmd_age_ms | Bytes 6-7 (LE) | 増減する値（0-65535 ms） |
| battery_mv | Bytes 8-9 (LE) | `0x1CE8` (7400 mV, スタブ実装) |
| reserved | Bytes 10-11 | `0x0000` |

#### Telemetryパケット構造（詳細）

```
Offset | Size | Field           | 値の例     | 説明
-------|------|-----------------|-----------|----------------------------------
0      | 1    | version         | 0x01      | プロトコルバージョン v0.1
1      | 1    | msg_type        | 0x10      | TELEMETRY
2      | 1    | payload_len     | 0x08      | ペイロード長（8 bytes）
3      | 1    | reserved        | 0x00      | 予約
4      | 1    | state           | 0x00-0x02 | DISARMED/ARMED/FAULT
5      | 1    | error_code      | 0x00-0xFF | エラーコード
6      | 2    | last_cmd_age_ms | 0x0000-   | 最終コマンド経過時間（LE）
8      | 2    | battery_mv      | 0x1CE8    | バッテリー電圧 mV（LE）
10     | 2    | reserved        | 0x0000    | 予約
```

#### フィールド値の詳細

**state** (Byte 4):
- `0x00`: DISARMED（初期状態、DISARM後）
- `0x01`: ARMED（ARM後）
- `0x02`: FAULT（デッドマンタイムアウト、切断後）

**error_code** (Byte 5):
- `0x00`: ERR_NONE（正常）
- `0x01`: ERR_DEADMAN_TIMEOUT（デッドマンタイムアウト）
- その他: 将来の拡張用

**last_cmd_age_ms** (Bytes 6-7, Little Endian):
- 例: `0x0032` → 50 ms
- 例: `0x00C8` → 200 ms
- 例: `0xFFFF` → 65535 ms（最大値）

**battery_mv** (Bytes 8-9, Little Endian):
- v0.1: `0x1CE8` (7400 mV) 固定値（スタブ実装）
- 将来: 実際のバッテリー電圧

#### 成功/失敗の判断基準

**成功**:
- 5秒間で約50パケット受信される（10 Hz周期）
- 受信周期が安定している（±10ms程度）
- パケット長が常に12 bytesである
- すべてのフィールドが仕様通りの値である
- state, error_code, last_cmd_age_ms が動的に変化する
- battery_mv が固定値7400 mVである（v0.1仕様）

**失敗**:
- 受信周期が不安定（100ms ± 20ms以上のバラつき）
- パケットが欠損する（連続3パケット以上の欠損）
- フィールド値が異常（例: stateが0x03以上）
- battery_mv が7400 mV以外の値（v0.1では異常）

#### 注意事項

- **battery_mv は v0.1 ではスタブ実装**です。固定値7400 mVが返されます。これは仕様通りの動作です
- Telemetryは**周期駆動**（10 Hz固定）であり、イベント駆動ではありません
- `last_cmd_age_ms` はオーバーフロー（65535 ms超）時に65535にクランプされます

---

## 3. 受け入れ基準の確認

Sprint 1の受け入れ基準が満たされていることを確認します。

### M1受け入れ基準

| 受け入れ基準 | 対応テストシナリオ | 判定 |
|---------|------------------|------|
| BLEテストアプリから Write するとサーボが所定角度へ動く | TS-03 | テスト実施後に記入 |
| 同じ操作を10回以上繰り返してもハングしない | TS-03（複数回実施） | テスト実施後に記入 |

### M2受け入れ基準

| 受け入れ基準 | 対応テストシナリオ | 判定 |
|---------|------------------|------|
| 切断/無通信で確実に停止する | TS-04, TS-05 | テスト実施後に記入 |
| テレメトリが所定周期で通知される（10Hz） | TS-06 | テスト実施後に記入 |

### Sprint 1全体の受け入れ基準

すべてのテストシナリオ（TS-01 ～ TS-06）が**成功**と判定された場合、Sprint 1の受け入れ基準を満たします。

---

## 4. テスト結果記録フォーマット

テスト実施時は、以下のフォーマットで結果を記録してください。

### テストシナリオ結果

```
テストシナリオ: TS-XX
実施日時: YYYY-MM-DD HH:MM
実施者: [名前]
ファームウェアバージョン: [バージョン/コミットハッシュ]

【結果】: 成功 / 失敗

【観測値】:
- [観測点1]: [実際の値]
- [観測点2]: [実際の値]
...

【備考】:
[気づいた点、トラブルシューティングの内容など]
```

### 全体結果サマリー

```
Sprint 1 受け入れテスト結果サマリー

実施日: YYYY-MM-DD
実施者: [名前]

| テストシナリオ | 結果 | 備考 |
|--------------|------|------|
| TS-01 | ✅/❌ | |
| TS-02 | ✅/❌ | |
| TS-03 | ✅/❌ | |
| TS-04 | ✅/❌ | |
| TS-05 | ✅/❌ | |
| TS-06 | ✅/❌ | |

【総合判定】: 合格 / 不合格

【推奨事項】:
[改善提案、次のステップなど]
```

---

## 5. トラブルシューティング

### 5.1 接続に関する問題

**症状**: デバイスが見つからない、または接続できない

**確認事項**:
1. XIAOが起動しているか（LED確認）
2. ファームウェアが書き込まれているか
3. 他のデバイスが接続していないか（1対1接続のみ）
4. Bluetoothが有効になっているか（スマートフォン/PC）

**対処法**:
- XIAOをリセット（RSTボタン）
- BLEテストアプリを再起動
- スマートフォン/PCのBluetoothをオフ→オンにする

### 5.2 サーボに関する問題

**症状**: サーボが動かない

**確認事項**:
1. ARMED状態になっているか（Telemetry確認）
2. サーボに電源が供給されているか
3. I2C配線が正しいか（SDA/SCL/GND）
4. サーボがCH0に接続されているか

**対処法**:
- `docs/wiring_pca9685.md` を参照して配線を再確認
- シリアルログでI2Cエラーを確認
- 別のサーボで試す

**症状**: サーボの動きが異常（ジッタ、意図しない動き）

**確認事項**:
1. パルス幅のエンディアンが正しいか（Little Endian）
2. サーボの種類が適切か（500-2500 us対応）
3. 電源電圧が適切か（5-6V推奨）

### 5.3 Telemetryに関する問題

**症状**: Telemetryが受信できない

**確認事項**:
1. Notifyが有効化されているか
2. CCCDが設定されているか（アプリによる）
3. BLE接続が維持されているか

**対処法**:
- Notifyアイコンをタップして再度有効化
- 一度切断して再接続
- 別のBLEテストアプリを試す

**症状**: Telemetryの周期が不安定

**確認事項**:
1. BLEの電波状況（RSSIが-80 dBm以上推奨）
2. 他のBLEデバイスの干渉
3. ファームウェアの負荷状況（シリアルログ確認）

### 5.4 状態遷移に関する問題

**症状**: ARM/DISARMが動作しない

**確認事項**:
1. コマンドのフォーマットが正しいか（Hex値確認）
2. Write typeが "Write Without Response" になっているか
3. 正しいCharacteristicに送信しているか（Command Char: `...789abd`）

**対処法**:
- `docs/ble_protocol.md` のコマンド一覧を参照
- シリアルログでコマンド受信を確認
- バイト値を再確認

---

## 6. 参照ドキュメント

本テスト計画は、以下のドキュメントに基づいています：

1. **BLEプロトコル詳細**: `docs/ble_protocol.md`
   - GATT Service/Characteristic構成
   - 手動テスト手順（nRF Connect / LightBlue）
   - コマンド送信例

2. **プロトコル仕様**: `shared/protocol/spec/legctrl_protocol.md`
   - メッセージフォーマット
   - 状態定義
   - コマンド/テレメトリ詳細

3. **安全システムテスト**: `docs/safety_test.md`
   - TC-01 ～ TC-11（詳細テストケース）
   - 受け入れ基準

4. **受け入れ検証**: `docs/S1-08_acceptance_validation.md`
   - S1-08テレメトリ実装の検証

5. **配線ガイド**: `docs/wiring_pca9685.md`
   - I2C配線
   - 電源接続

6. **マイルストーン**: `MILESTONE.md`
   - M1, M2の定義と受け入れ基準

---

## 7. 改訂履歴

| Version | Date       | Author   | Changes                                    |
|---------|------------|----------|--------------------------------------------|
| v1.0    | 2026-01-03 | copilot  | 初版作成（Sprint 1 手動テスト計画）         |

---

## 付録A: 使用するBLEテストアプリのスクリーンショット（参考）

### nRF Connect for Mobile

1. **スキャン画面**: デバイス一覧
2. **接続後画面**: Service一覧
3. **Characteristic画面**: Command/Telemetry
4. **Write画面**: Hex入力
5. **Notify画面**: Telemetryデータ表示

### LightBlue

1. **スキャン画面**: デバイス一覧
2. **Peripheral画面**: Service一覧
3. **Characteristic詳細**: Read/Write/Notify
4. **Hex入力画面**: Write操作
5. **Notify受信画面**: リアルタイムデータ

> 注: 実際のスクリーンショットは各アプリのバージョンによって異なる場合があります。

---

**このドキュメントを使用して、第三者が Sprint 1 の受け入れ条件を完全に検証できることを確認してください。**
